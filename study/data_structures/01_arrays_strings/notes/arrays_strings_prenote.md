# 문자열 공부 노트

## 1. 처음에 잘못 이해했던 점
- 문자열은 리스트처럼 값이 바뀌는 자료형이라고 생각했다.
- 실제로는 한 글자라도 바꾸면 새로운 문자열이 만들어진다.

## 2. 시간 복잡도에서 헷갈렸던 부분
- 반복문 안에서 문자열에 `+=`를 사용하면 매번 새 문자열이 생성된다.
- 이 방식은 전체적으로 O(n²)가 될 수 있다.
- 해결 방법: 리스트에 문자들을 모은 뒤 한 번에 합친다.

## 3. 문자열 처리에서 자주 쓰이는 판단 기준
- 문자의 개수나 빈도를 비교해야 하면 딕셔너리를 떠올린다.
- 가장 길거나 가장 짧은 부분 문자열을 찾는 문제는 구간을 유지하는 방식으로 접근한다.
- 앞뒤를 비교하는 문제는 왼쪽, 오른쪽 포인터를 둔다.

## 4. 파이썬 문자열의 특징
- 문자열은 인덱스로 바로 접근할 수 있다.
- 슬라이싱은 새로운 문자열을 만들기 때문에 비용이 든다.
- replace, lower 같은 함수는 원본을 바꾸지 않고 새 문자열을 반환한다.

## 5. 문제를 풀면서 막혔던 지점
- 연속된 문자만 허용되는 문제에서 이전 문자를 저장하지 않아 로직이 꼬였다.
- 해결 방법은 현재 문자와 이전 문자를 비교하면서 상태를 관리하는 것이었다.

## 6. 다음에 같은 유형을 만나면
- 문자열을 직접 수정하려고 하지 않는다.
- 먼저 리스트로 바꿀 수 있는지 고민한다.
- 불변이라는 특성을 먼저 떠올린다.

문자열은 순서가 있는 자료형이다
예를 들면 s = "abc"에서 s[1]= b를 의미하는 것처럼
그래서 한번 정해지면 내부 값을 바꿀 수 없다
기존 문자열을 수정하는게 아닌 조각으로 나누고 새로운 문자열을 합치는 방식으로 수정을한다
그래서 시간복잡도가 증가하게 된다

전역후 오랜만에 다시 공부하는거라 시간복잡도에 대해 간단히 정리하고 가보자
for i in range(n):
    print(i)

한번만 도는 반복문은 O(n)이고 
for i in range(n):
    for j in range(n):
        print(i, j)

이건 중첩되어 O(n²)으로 표현한다

for i in range(n):
    pass

for j in range(n):
    pass

이건 상수가 2n이 나오지만 상수는 계산하면서 지운다

for i in range(n):
    for j in range(m):
        pass

이렇게 되었을때 코드가 서로 다른 입력크기에 의존할때는 O(nm)로 표현한다(예를 들면 2가지 입력일떄)
몰랐던 점이다

조건문은 무시하고 
s[i] 처럼 인덱스에 접근시에 한번 접근하는건 O(1)이다

문자열 슬라이싱 s[:k]과 문자열 덧붙이기 s = s + "a"가 O(n)으로 계산되는데 나는 직관적으로 O(1)이라고 생각했다
겉으로 보면:
	•	기존 문자열 뒤에 "a" 하나만 붙임
	•	그래서 O(1)처럼 보임

하지만 실제로는:

컴퓨터가 하는 일
	1.	기존 문자열 s의 길이를 확인한다 (n)
	2.	길이 n+1짜리 새로운 공간을 메모리에 확보
	3.	기존 문자열의 모든 문자 n개를 하나씩 새 공간으로 복사
	4.	마지막에 "a"를 붙인다
	5.	새 문자열을 s에 대입한다

👉 중요한 건 3번이야.

기존 문자열이 길이 100이면
100글자를 전부 다시 복사해야 한다.

그래서 시간은:
	•	한 글자 붙였는데도
	•	기존 길이 n에 비례

👉 O(n)
라고 답을 받았는데 나는 왜 문자열 길이를 확인하는데 n이라는 시간이 드는지 의문을 가졌다

찾아본 결과 하나를 덛붙이면 문자 하나하나 쪼개서 매모리에 저장한다음 새로운 종이에 쓰는 방식으로 컴퓨터가 작동해서라고 한다
결국 정리하면
문자열 연산의 시간은
‘내가 바꾼 글자 수’가 아니라
‘새로 복사된 글자 수’로 결정된다.

문자열은 불변이라
한 글자를 바꿔도 전체를 다시 만든다.

비슷한 이유로 s[:k]도 문자열을 만든후 글자를 하나씩 더하는 과정이기 때문에 그렇다고 이해했다

결론적으로 문자열은 순서가 있고 변경할 수 없으며(변경하려면 새로 만들기 때문)이다
가능한연산은 인덱스로 읽기 순회하기(처음부터 끝까지 읽기) 슬라이싱으로 새 문자열 만들기가 있다
불가능한건 직접 중간값을 수정할 수 없다

진짜 중요하다고 생각하는 시간복잡도에 대한건
	•	인덱스 접근 → O(1)
	•	길이 확인 → O(1)
	•	슬라이싱 → O(n)
	•	문자열 덧붙이기 → O(n)
	•	반복문 안에서 문자열 덧붙이기 → O(n²)
들로 봤을때 복사되는 글자수가 시간복잡도를 결정한다고 이해했다. 직관이 아닌 컴퓨터에 관점으로 생각해야 한다는 것과

문자열에서 자주 사용되는 사고 패턴은(여기는 문제풀면서 공부)
	•	문자 개수 비교 → 딕셔너리
	•	가장 길다 / 가장 짧다 → 구간 유지 방식
	•	앞뒤 비교 → 양쪽에서 접근
	•	결과 문자열이 꼭 필요한지 먼저 생각
리스트
arr = [10, 20, 30]
딕셔너리
{
    "b": 1,
    "a": 3,
    "n": 2
}

1.	문자 빈도 비교는 딕셔너리가 가장 직관적이고 효율적이다
	2.	“가장 긴/짧은 연속 구간”은 구간 유지 방식이 기본 해법이다
	3.	좌우 조건이 있으면 양쪽에서 접근하는 방식이 강력하다
	4.	문자열을 새로 만들지 말고, 결과가 정말 필요한지 먼저 따져라
	5.	문자열은 읽기/비교에 강하고, 리스트는 수정/누적에 강하다


7️⃣ implementations에 작성할 것

문자열 관련 구현 파일 예시:
	•	문자열 불변성 실험 코드
	•	슬라이싱과 덧붙이기 시간 비교
	•	리스트로 바꿔서 처리하는 예제

