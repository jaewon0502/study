# 문자열 공부 정리

# 문자열이 어떤 자료형인지
- 문자열은 순서가 있는 자료형이다
- 예를 들면 s = "abc"에서 s[1]은 "b"를 의미한다
- 그래서 한 번 정해지면 내부 값을 직접 바꿀 수 없다
- 문자열을 “수정”한다는 건 기존 문자열을 바꾸는 게 아니라 조각으로 나누고 새로운 문자열을 합치는 방식이다
- 그래서 문자열 관련 연산은 상황에 따라 시간 복잡도가 커질 수 있다

# 시간 복잡도 기본 정리
- 전역 후 오랜만에 다시 공부하는 거라 시간 복잡도부터 간단히 정리하고 간다

## 한 번만 도는 반복문
```python
for i in range(n):
    print(i)

	•	한 번만 도는 반복문은 O(n)이다

중첩 반복문

for i in range(n):
    for j in range(n):
        print(i, j)

	•	중첩되면 O(n^2)으로 표현한다

반복문이 순서대로 두 번 있는 경우

for i in range(n):
    pass

for j in range(n):
    pass

	•	2n이지만 상수는 지우니까 O(n)이다

서로 다른 입력 크기에 의존하는 중첩 반복문

for i in range(n):
    for j in range(m):
        pass

	•	서로 다른 입력 크기에 의존하면 O(nm)로 표현한다
	•	예를 들면 입력이 두 가지 크기로 따로 존재할 때 이런 식이다
	•	이건 내가 몰랐던 점이다

조건문은 보통 무시
	•	반복문 안에 조건문이 있어도 반복 횟수가 바뀌지 않으면 큰 틀에서 O(n)으로 본다

문자열에서 시간 복잡도가 커지는 이유

인덱스 접근

s[i]

	•	한 번 접근은 O(1)이다

길이 확인

len(s)

	•	길이 확인은 O(1)이다
	•	내가 의문 가졌던 “길이 확인이 n만큼 드나?”는 결론적으로 아니다

슬라이싱

s[:k]

	•	s[:k]는 0부터 k-1까지, 즉 앞에서 k개를 잘라서 새로운 문자열을 만든다
	•	슬라이싱은 새 문자열을 만들고 문자를 복사하는 과정이 있어서 O(k)이고, 보통 k가 n급이면 O(n)으로 본다
	•	그리고 새 문자열이 하나 더 생긴다

문자열 덧붙이기

s = s + "a"

	•	겉으로 보면 뒤에 “a” 하나만 붙이는 것 같아서 O(1)처럼 느껴졌다
	•	근데 실제로는 새 문자열 공간을 만들고 기존 문자열 전체를 복사한 뒤 마지막에 “a”를 붙이는 방식이라 O(n)이다
	•	중요한 건 “길이를 확인해서 n이 드는 게 아니라” 기존 문자열을 통째로 복사하는 과정이 n에 비례한다는 점이다

내가 이해한 결론
	•	문자열 연산의 시간은 “내가 바꾼 글자 수”가 아니라 “새로 복사된 글자 수”로 결정된다
	•	문자열은 불변이라 한 글자를 바꾸는 것도 결국 전체를 새로 만드는 쪽으로 귀결된다
	•	비슷한 이유로 s[:k]도 새 문자열을 만들고 복사하는 과정이 들어간다고 이해했다

문자열에서 가능한 연산 / 불가능한 연산

가능한 연산
	•	인덱스로 읽기
	•	순회하기(처음부터 끝까지 읽기)
	•	슬라이싱으로 새 문자열 만들기

불가능한 연산
	•	중간 값을 직접 수정하기

진짜 중요하다고 생각하는 시간 복잡도 포인트
	•	인덱스 접근: O(1)
	•	길이 확인: O(1)
	•	슬라이싱: O(n)
	•	문자열 덧붙이기: O(n)
	•	반복문 안에서 문자열 덧붙이기: O(n^2)
	•	결국 복사되는 글자 수가 시간 복잡도를 결정한다고 이해했다
	•	직관이 아니라 컴퓨터 관점으로 생각해야 한다는 것도 같이

문자열 문제에서 자주 쓰는 사고 패턴(문제 풀면서 익힐 것)
	•	문자 개수 비교: 딕셔너리
	•	가장 길다 / 가장 짧다: 구간 유지 방식
	•	앞뒤 비교: 양쪽에서 접근
	•	결과 문자열이 꼭 필요한지 먼저 생각

리스트와 딕셔너리 예시

리스트

arr = [10, 20, 30]

딕셔너리

freq = {
    "b": 1,
    "a": 3,
    "n": 2
}

내가 적어둔 결론 요약
	•	문자 빈도 비교는 딕셔너리가 가장 직관적이고 효율적이다
	•	“가장 긴/짧은 연속 구간”은 구간 유지 방식이 기본 해법이다
	•	좌우 조건이 있으면 양쪽에서 접근하는 방식이 강력하다
	•	문자열을 새로 만들지 말고 결과가 정말 필요한지 먼저 따져라
	•	문자열은 읽기/비교에 강하고 리스트는 수정/누적에 강하다

implementations에 작성할 것(나중에 코드로 확인)
	•	문자열 불변성 실험 코드
	•	슬라이싱과 덧붙이기 시간 비교
	•	리스트로 바꿔서 처리하는 예제

